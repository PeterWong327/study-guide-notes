- What is the best solution to this problem?
  - The best solution is to use QuickSelect to sort an array, in which a random pivot element is selected. The pivot element is selected by randomly generating an index between 1 and r, and then partitioning around the random element. Then compare the random element's position with k. If it is less than k, then recur for the right subarray. If greater than k, then recur for the left subarray. Repeat until position is equal to k. Time complexity is expected to be linear time, while worst case is exponential.

- Compare using a min-heap and a max-heap to
solve this problem.
  - Using a min-heap/max-heap, we can get the kth smallest element (kth largest for max-heap) by building a min-heap (max-heap) with the size of k, and then iterating through the array starting at the index (array length - k). Each element is compared to the root, and if it is smaller (larger, if max-heap), then it replaces the root. Return root a the end.
  Time complexity is O(k + (n-k)(logk)).


- What does the async keyword do?


- What does the await keyword do?


- what does console.dir() do?


- What happens if you set innerHTML to a
script?


- What does the .hidden property do?


- What is SQL injection? How do you avoid it?
  - (59:35)
