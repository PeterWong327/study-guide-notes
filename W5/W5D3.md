- How does Interpolation Search Work?
  - Interpolation Search works by calculating the value of a position given the starting and ending indices of an array. The the value is then compared to the target value. If the target value is less than the value of the calculated position, then the search continues in the subarray that ends at the calculated position - 1. Else if the target is higher, the search continues in the subarray that begins at the calculated position + 1. The 'probe' position is calculated by: **startIndex + [ (target - arr[startIndex])* (endIndex - startIndex) / (arr[endIndex] - arr[startIndex]) ]**


- What is its expected time complexity, and what is its worst time complexity? Why?
  - Its expected time complexity is O(log(log(n))) if the elements are uniformly distributed, while its worst case can take up to O(n) if the key values increase exponentially.


- When would you want to use Promise.resolve()?
  - You use Promise.resolve() when you already have a value, but want to have the value 'wrapped' into a promise, so that the value can be used in a '.then' that is chained to the function that has the Promise.resolve().
  

- Explain how Promise.all works.


- What happens when you pass a non-promise object in the iterable you

pass to Promise.all?
- What is Promise.race


- What is the DOM?


- What happens when you omit the head tag or the body tag in your HTML?


- What happens if you include more tags after the tag?


- What kind of object is returned by .childNodes?


- Talk about the different ways your can access DOm elements in jS


- What are two important properties of DOM collections?


- What's the difference between calling .childnodes and calling
.children?


- Explain Diffie-Hellman key exchange. Why does it work?
